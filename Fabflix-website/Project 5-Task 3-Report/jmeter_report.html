 <!DOCTYPE html>
<html>
<head>
<style>
body {
    background-color: linen;
}

td {
    border-top-style: solid;
}
</style>
</head>
<body>

<table style="width:100%">
  <tr style="font-weight:bold; background-color: orange">
    <td width="300px">Single-instance version cases</td>
    <td>Graph Results Screenshot</td>
    <td>Average Query Time(ms)</td>
    <td>Average Search Servlet Time(ms)</td>
    <td>Average JDBC Time(ms)</td>
    <td>Analysis</td>
  </tr>
  <tr>
    <td>Case 1: HTTP/1 thread</td>
    <td><img src="1-3.png" alt="Graph Results Screenshot Case 1" style="width:304px;height:228px;"></td>
    <td>89</td>
    <td>1.5199333675246027</td>
    <td>1.0662397971233915</td>
    <td>For all cases, the average query time is much slower than the average search servlet time because the query time includes the connection time of sending a request from the client and receiving responses from the server. In addition, the average query time also includes the graph GUI latency. The average search servlet time includes jdbc connection. Therefore, the average search servlet time is always larger than the average JDBC time. The average search servlet time is the time it takes for the search servlet to run completely for a query. The average JDBC time is the time that is spent on JDBC execution.
      The reason why the blue line on the graph is not showing is explained the configuration in JMeter. The number on the top left corner is 80ms, which is max of 90th percentile of the response time, and data larger than 80ms is hardly visible. In some of the data, because of network, the data sample flutuates a lot and it did not show the average query time of 89ms (according to the JMeter documentation).
    </td>
  </tr>
  <tr>
    <td>Case 2: HTTP/10 threads</td>
    <td><img src="1-4.png" alt="Graph Results Screenshot Case 2" style="width:304px;height:228px;"></td>
    <td>84</td>
    <td>2.439450902346707</td>
    <td>1.6881858440575324</td>
    <td>The average query time is smaller than the the time in case 1 because it has 10 threads runing simultaneously. That means it is faster to send queries but slower to receive the response. That's why the average query time is similar to the average query time in case 1. The other times are similar and follows the analysis in case 1. </td>
  </tr>
  <tr>
    <td>Case 3: HTTPS/10 threads</td>
    <td><img src="1-5.png" alt="Graph Results Screenshot Case 3" style="width:304px;height:228px;"></td>
    <td>89</td>
    <td>2.500434522331567</td>
    <td>1.7617378338380016</td>
    <td>The average query time is slower than that of case 2 with the same amount of threads becuase of the overhead in encryption of HTTPS. </td>
  </tr>
  <tr>
    <td>Case 4: HTTP/10 threads/No prepared statements</td>
    <td><img src="1-1.png" alt="Graph Results Screenshot Case 4" style="width:304px;height:228px;"></td>
    <td>84</td>
    <td>1.6527303981831944</td>
    <td>1.1810643141559425</td>
    <td>PreparedStatement is precompiled, so it is faster to execute similar queries with different parameters. The average query time of this case is similar to that of case 2 with the same amount of threads. Becuase of uncertainty in network data transfer, sample reposonse time may fluctuate. The same reason of blue line not showing is explained in case 1 above. </td>
  </tr>
  <tr>
    <td>Case 5: HTTP/10 threads/No connection pooling</td>
    <td><img src="1-2.png" alt="Graph Results Screenshot Case 5" style="width:304px;height:228px;"></td>
    <td>86</td>
    <td>2.017341802043906</td>
    <td>1.5354422255866766</td>
    <td>Connection pooling is faster because it puts existing connections into the pool. When users make requests, it first
      look up if there is an available connection in the pool without creating a new connection. So, the average query time without conenction
      pooling is slower than time in case 2.</td>
  </tr>

</table> 


<table style="width:100%">
  <tr style="font-weight:bold; background-color: orange">
    <td width="300px">Scaled version cases</td>
    <td>Graph Results Screenshot</td>
    <td>Average Query Time(ms)</td>
    <td>Average Search Servlet Time(ms)</td>
    <td>Average JDBC Time(ms)</td>
    <td>Analysis</td>
  </tr>
  <tr>
    <td>Case 1: HTTP/1 thread</td>
    <td><img src="2-3.png" alt="Graph Results Screenshot Case 1" style="width:304px;height:228px;"></td>
    <td>87</td>
    <td>3.613384427706283</td>
    <td>2.2855803126419376</td>
    <td>The average query time is faster than that of case 1 in the above section where single servlet is given. The reason why the
      scaled version is faster is that it distributes requests to multiple instances. This has relieved the hardware pressure and in return improved
      the performance. 
    </td>
  </tr>
  <tr>
    <td>Case 2: HTTP/10 threads</td>
    <td><img src="2-4.png" alt="Graph Results Screenshot Case 2" style="width:304px;height:228px;"></td>
    <td>84</td>
    <td>2.8894645821347464</td>
    <td>2.1755606926570783</td>
    <td> The average query time is smaller than the the time in case 1 because it has 10 threads running simultaneously. That means it is faster to send queries but slower to receive the response.
      The same reason of blue line not showing is explained in case 1 above in the single instance section. 
    </td>
  </tr>
  <tr>
    <td>Case 3: HTTP/10 threads/No prepared statements</td>
    <td><img src="2-1.png" alt="Graph Results Screenshot Case 4" style="width:304px;height:228px;"></td>
    <td>84</td>
    <td>1.6266566048448146</td>
    <td>1.2345718671461015</td>
    <td>PreparedStatement is precompiled, so it is faster to execute similar queries with different parameters. The average query time of this case is similar to that of case 2 with the same amount of threads.</td>
  </tr>
  <tr>
    <td>Case 4: HTTP/10 threads/No connection pooling</td>
    <td><img src="2-2.png" alt="Graph Results Screenshot Case 4" style="width:304px;height:228px;"></td>
    <td>85</td>
    <td>3.274502720287661</td>
    <td>2.3353061801665405</td>
    <td>Connection pooling is faster because it puts existing connections into a pool. When users make requests, it first
        looks up if there is an available connection in the pool without creating a new connection. So, the average query time without conenction
        pooling is slower than time in case 2.</td>
  </tr>

</table> 

</body>
</html>
